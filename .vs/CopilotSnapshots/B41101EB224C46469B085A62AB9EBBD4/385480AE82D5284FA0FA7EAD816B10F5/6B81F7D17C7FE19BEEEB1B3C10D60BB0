using System;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;

namespace wraithspire.engine.objects
{
    internal sealed class CheckboardTerrain : IDisposable
    {
        private int _vao;
        private int _vbo;
        private int _ebo;
        private int _shader;
        private int _projLoc;
        private int _viewLoc;
        private int _modelLoc;
        private int _scaleLoc;

        public float CellSize { get; set; } = 1.0f; // world units per checker cell
        public float BoardScale { get; set; } = 500f; // size of rendered quad (big enough to look infinite)

        public void Initialize()
        {
            CreateShader();
            BuildMesh();
        }

        private void CreateShader()
        {
            const string vs = "#version 330 core\n" +
                              "layout(location=0) in vec3 in_pos;\n" +
                              "out vec3 v_worldPos;\n" +
                              "uniform mat4 u_proj;\n" +
                              "uniform mat4 u_view;\n" +
                              "uniform mat4 u_model;\n" +
                              "void main(){\n" +
                              "  vec4 wp = u_model * vec4(in_pos,1.0);\n" +
                              "  v_worldPos = wp.xyz;\n" +
                              "  gl_Position = u_proj * u_view * wp;\n" +
                              "}";

            const string fs = "#version 330 core\n" +
                              "in vec3 v_worldPos;\n" +
                              "out vec4 out_color;\n" +
                              "uniform float u_cellSize;\n" +
                              "void main(){\n" +
                              "  // Use world XZ to compute checker index\n" +
                              "  float cx = floor(v_worldPos.x / u_cellSize);\n" +
                              "  float cz = floor(v_worldPos.z / u_cellSize);\n" +
                              "  float parity = mod(cx + cz, 2.0);\n" +
                              "  vec3 c1 = vec3(0.85, 0.86, 0.88);\n" +
                              "  vec3 c2 = vec3(0.70, 0.72, 0.74);\n" +
                              "  vec3 color = mix(c1, c2, parity);\n" +
                              "  out_color = vec4(color, 1.0);\n" +
                              "}";

            int vert = GL.CreateShader(ShaderType.VertexShader);
            GL.ShaderSource(vert, vs);
            GL.CompileShader(vert);
            int frag = GL.CreateShader(ShaderType.FragmentShader);
            GL.ShaderSource(frag, fs);
            GL.CompileShader(frag);
            _shader = GL.CreateProgram();
            GL.AttachShader(_shader, vert);
            GL.AttachShader(_shader, frag);
            GL.LinkProgram(_shader);
            GL.DeleteShader(vert);
            GL.DeleteShader(frag);
            _projLoc = GL.GetUniformLocation(_shader, "u_proj");
            _viewLoc = GL.GetUniformLocation(_shader, "u_view");
            _modelLoc = GL.GetUniformLocation(_shader, "u_model");
            _scaleLoc = GL.GetUniformLocation(_shader, "u_cellSize");
        }

        private void BuildMesh()
        {
            // Single large quad centered at origin in XZ plane
            float half = BoardScale * 0.5f;
            float[] vertices = new float[]
            {
                -half, 0f, -half,
                 half, 0f, -half,
                 half, 0f,  half,
                -half, 0f,  half
            };
            int[] indices = new int[] { 0, 1, 2, 0, 2, 3 };

            _vao = GL.GenVertexArray();
            _vbo = GL.GenBuffer();
            _ebo = GL.GenBuffer();

            GL.BindVertexArray(_vao);
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vbo);
            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * sizeof(float), vertices, BufferUsageHint.StaticDraw);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _ebo);
            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * sizeof(int), indices, BufferUsageHint.StaticDraw);
            GL.EnableVertexAttribArray(0);
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, 3 * sizeof(float), 0);
        }

        public void Render(int viewportWidth, int viewportHeight)
        {
            if (_vao == 0) return;

            GL.UseProgram(_shader);
            // Simple camera looking down the XZ plane
            var proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(60f), viewportWidth / (float)viewportHeight, 0.1f, 2000f);
            var view = Matrix4.LookAt(new Vector3(0f, 20f, 25f), Vector3.Zero, Vector3.UnitY);
            var model = Matrix4.Identity;
            GL.UniformMatrix4(_projLoc, false, ref proj);
            GL.UniformMatrix4(_viewLoc, false, ref view);
            GL.UniformMatrix4(_modelLoc, false, ref model);
            GL.Uniform1(_scaleLoc, CellSize);

            GL.BindVertexArray(_vao);
            GL.DrawElements(PrimitiveType.Triangles, CellsX * CellsY * 6, DrawElementsType.UnsignedInt, 0);
            GL.BindVertexArray(0);
            GL.UseProgram(0);
        }

        public void Dispose()
        {
            if (_vao != 0) GL.DeleteVertexArray(_vao);
            if (_vbo != 0) GL.DeleteBuffer(_vbo);
            if (_ebo != 0) GL.DeleteBuffer(_ebo);
            if (_shader != 0) GL.DeleteProgram(_shader);
            _vao = _vbo = _ebo = _shader = 0;
        }
    }
}
