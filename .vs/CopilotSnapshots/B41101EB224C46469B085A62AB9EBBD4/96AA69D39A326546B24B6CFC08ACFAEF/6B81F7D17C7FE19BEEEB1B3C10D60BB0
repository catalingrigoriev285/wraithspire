using System;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;

namespace wraithspire.engine.objects
{
    internal sealed class CheckboardTerrain : IDisposable
    {
        private int _vao;
        private int _vbo;
        private int _ebo;
        private int _shader;
        private int _projLoc;
        private int _viewLoc;
        private int _modelLoc;

        public int CellsX { get; set; } = 16;
        public int CellsY { get; set; } = 16;
        public float CellSize { get; set; } = 1.0f;

        public void Initialize()
        {
            CreateShader();
            BuildMesh();
        }

        private void CreateShader()
        {
            const string vs = "#version 330 core\n" +
                              "layout(location=0) in vec3 in_pos;\n" +
                              "layout(location=1) in vec3 in_color;\n" +
                              "out vec3 v_color;\n" +
                              "uniform mat4 u_proj;\n" +
                              "uniform mat4 u_view;\n" +
                              "uniform mat4 u_model;\n" +
                              "void main(){\n" +
                              "  v_color = in_color;\n" +
                              "  gl_Position = u_proj * u_view * u_model * vec4(in_pos,1.0);\n" +
                              "}";

            const string fs = "#version 330 core\n" +
                              "in vec3 v_color;\n" +
                              "out vec4 out_color;\n" +
                              "void main(){\n" +
                              "  out_color = vec4(v_color, 1.0);\n" +
                              "}";

            int vert = GL.CreateShader(ShaderType.VertexShader);
            GL.ShaderSource(vert, vs);
            GL.CompileShader(vert);
            int frag = GL.CreateShader(ShaderType.FragmentShader);
            GL.ShaderSource(frag, fs);
            GL.CompileShader(frag);
            _shader = GL.CreateProgram();
            GL.AttachShader(_shader, vert);
            GL.AttachShader(_shader, frag);
            GL.LinkProgram(_shader);
            GL.DeleteShader(vert);
            GL.DeleteShader(frag);
            _projLoc = GL.GetUniformLocation(_shader, "u_proj");
            _viewLoc = GL.GetUniformLocation(_shader, "u_view");
            _modelLoc = GL.GetUniformLocation(_shader, "u_model");
        }

        private void BuildMesh()
        {
            int vertsPerRow = CellsX + 1;
            int vertsPerCol = CellsY + 1;
            int vertexCount = vertsPerRow * vertsPerCol;
            int stride = 6; // pos(3) + color(3)
            float[] vertices = new float[vertexCount * stride];

            for (int y = 0; y < vertsPerCol; y++)
            {
                for (int x = 0; x < vertsPerRow; x++)
                {
                    int i = (y * vertsPerRow + x) * stride;
                    float px = x * CellSize;
                    float py = 0f;
                    float pz = y * CellSize;
                    vertices[i + 0] = px;
                    vertices[i + 1] = py;
                    vertices[i + 2] = pz;
                    bool dark = ((x + y) % 2) == 0;
                    var col = dark ? new Vector3(0.18f, 0.20f, 0.24f) : new Vector3(0.26f, 0.30f, 0.34f);
                    vertices[i + 3] = col.X;
                    vertices[i + 4] = col.Y;
                    vertices[i + 5] = col.Z;
                }
            }

            int quadsX = CellsX;
            int quadsY = CellsY;
            int indexCount = quadsX * quadsY * 6; // two triangles per cell
            int[] indices = new int[indexCount];
            int idx = 0;
            for (int y = 0; y < quadsY; y++)
            {
                for (int x = 0; x < quadsX; x++)
                {
                    int tl = y * vertsPerRow + x;
                    int tr = tl + 1;
                    int bl = (y + 1) * vertsPerRow + x;
                    int br = bl + 1;
                    // tri 1
                    indices[idx++] = tl;
                    indices[idx++] = bl;
                    indices[idx++] = tr;
                    // tri 2
                    indices[idx++] = tr;
                    indices[idx++] = bl;
                    indices[idx++] = br;
                }
            }

            _vao = GL.GenVertexArray();
            _vbo = GL.GenBuffer();
            _ebo = GL.GenBuffer();

            GL.BindVertexArray(_vao);
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vbo);
            GL.BufferData(BufferTarget.ArrayBuffer, vertices.Length * sizeof(float), vertices, BufferUsageHint.StaticDraw);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, _ebo);
            GL.BufferData(BufferTarget.ElementArrayBuffer, indices.Length * sizeof(int), indices, BufferUsageHint.StaticDraw);

            GL.EnableVertexAttribArray(0);
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, stride * sizeof(float), 0);
            GL.EnableVertexAttribArray(1);
            GL.VertexAttribPointer(1, 3, VertexAttribPointerType.Float, false, stride * sizeof(float), 3 * sizeof(float));
        }

        public void Render(int viewportWidth, int viewportHeight)
        {
            if (_vao == 0) return;

            GL.UseProgram(_shader);
            // Simple camera looking down the XZ plane
            var proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(60f), viewportWidth / (float)viewportHeight, 0.1f, 1000f);
            var view = Matrix4.LookAt(new Vector3(8f, 12f, 18f), new Vector3(8f, 0f, 8f), Vector3.UnitY);
            var model = Matrix4.Identity;
            GL.UniformMatrix4(_projLoc, false, ref proj);
            GL.UniformMatrix4(_viewLoc, false, ref view);
            GL.UniformMatrix4(_modelLoc, false, ref model);

            GL.BindVertexArray(_vao);
            GL.DrawElements(PrimitiveType.Triangles, CellsX * CellsY * 6, DrawElementsType.UnsignedInt, 0);
            GL.BindVertexArray(0);
            GL.UseProgram(0);
        }

        public void Dispose()
        {
            if (_vao != 0) GL.DeleteVertexArray(_vao);
            if (_vbo != 0) GL.DeleteBuffer(_vbo);
            if (_ebo != 0) GL.DeleteBuffer(_ebo);
            if (_shader != 0) GL.DeleteProgram(_shader);
            _vao = _vbo = _ebo = _shader = 0;
        }
    }
}
