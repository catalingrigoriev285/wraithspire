using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using OpenTK.Windowing.Common;
using OpenTK.Windowing.Desktop;
using OpenTK.Windowing.GraphicsLibraryFramework;
using wraithspire.engine.subsystems;
using wraithspire.engine.objects.primitives;
using ImGuiNET;

namespace wraithspire.engine
{
    internal sealed class Window : IDisposable
    {
        private readonly GameWindow _window;
        private ImGuiController? _imgui;
        private objects.CheckboardTerrain? _terrain;
        private EditorUI? _editorUI;
        private TransformGizmo? _gizmo;
        private List<Primitive> _sceneObjects = new List<Primitive>();
        private int _cubeCounter = 0;
        private Vector2 _lastMousePos;

        public Window(int width = 1280, int height = 720, string title = "Wraithspire Engine")
        {
            var nativeSettings = new NativeWindowSettings
            {
                ClientSize = new Vector2i(width, height),
                Title = title
            };

            var gwSettings = new GameWindowSettings
            {
                UpdateFrequency = 60
            };

            _window = new GameWindow(gwSettings, nativeSettings);
            _window.WindowState = WindowState.Maximized;

            _window.Load += OnLoad;
            _window.UpdateFrame += OnUpdateFrame;
            _window.RenderFrame += OnRenderFrame;
            _window.Resize += OnResize;
            _window.Unload += OnUnload;
            _window.MouseDown += OnMouseDown;
            _window.MouseUp += OnMouseUp;
            _window.MouseMove += OnMouseMove;
        }

        private void OnLoad()
        {
            GL.ClearColor(0.1f, 0.1f, 0.1f, 1f);
            _imgui = new ImGuiController(_window);
            _editorUI = new EditorUI();
            _editorUI.SceneObjects = _sceneObjects;
            _editorUI.OnCreateCube = CreateCube;
            _terrain = new objects.CheckboardTerrain();
            _terrain.Initialize();
            _gizmo = new TransformGizmo();
            _gizmo.Initialize();
        }

        private void OnUpdateFrame(FrameEventArgs args)
        {
            _imgui?.Update((float)args.Time);
            if (_editorUI != null)
            {
                var vp = GetViewportRect();
                _editorUI.UpdateCamera(_window, vp.Width, vp.Height);
            }
        }

        private void OnRenderFrame(FrameEventArgs args)
        {
            GL.Viewport(0, 0, _window.ClientSize.X, _window.ClientSize.Y);
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

            // Render UI first so the viewport rect computed by UI is valid for the 3D render + picking this frame.
            _editorUI?.Render(_window);
            RenderScene();

            _imgui?.Render();
            _window.SwapBuffers();
        }

        private void OnResize(ResizeEventArgs size)
        {
            _imgui?.WindowResized(size.Width, size.Height);
        }

        private void OnUnload()
        {
            _imgui?.Dispose();
            _terrain?.Dispose();
            _gizmo?.Dispose();
            foreach (var obj in _sceneObjects)
            {
                obj.Dispose();
            }
        }

        private void RenderScene()
        {
            if (_terrain == null) return;
            if (_editorUI == null) return;

            // Compute and use a single viewport rectangle consistently
            var vp = GetViewportRect();
            int glY = _window.ClientSize.Y - (vp.Y + vp.Height);
            GL.Viewport(vp.X, glY, vp.Width, vp.Height);
            GL.Enable(EnableCap.DepthTest);
            var proj = _editorUI.CameraProjection;
            var view = _editorUI.CameraView;
            _terrain.Render(proj, view);
            
            // Render all scene objects
            foreach (var obj in _sceneObjects)
            {
                obj.Render(proj, view);
            }
            
            // Render gizmo for selected object
            if (_gizmo != null && _editorUI.SelectedObject != null)
            {
                _gizmo.TargetObject = _editorUI.SelectedObject;
                _gizmo.Render(proj, view);
            }

            // Restore viewport to full window for UI render
            GL.Viewport(0, 0, _window.ClientSize.X, _window.ClientSize.Y);
        }

        private void CreateCube()
        {
            string name = _cubeCounter == 0 ? "Cube" : $"Cube ({_cubeCounter})";
            _cubeCounter++;
            
            var cube = new Cube(name);
            cube.Position = new Vector3(0f, 1f, 0f); // Place above ground
            cube.Initialize();
            _sceneObjects.Add(cube);
        }

        private void OnMouseDown(MouseButtonEventArgs e)
        {
            UpdateMousePositionFromState();

            if (e.Button == MouseButton.Left && _editorUI != null && _gizmo != null)
            {
                // Capture clicks anywhere that are NOT on ImGui windows; the 3D viewport is a "hole" between panels.
                if (!IsMouseInViewport() || ImGui.IsWindowHovered(ImGuiHoveredFlags.AnyWindow))
                    return;

                var mouseRay = GetViewportMouseRay();

                // Ensure gizmo hover state is updated before trying to start a drag.
                // Otherwise clicking without a prior MouseMove may leave _hoveredAxis=None.
                _gizmo.TargetObject = _editorUI.SelectedObject;
                _gizmo.CheckHover(mouseRay);
                
                // First try selecting an object directly through viewport
                var before = _editorUI.SelectedObject;
                TrySelectObject(mouseRay);

                // If we didn't change selection, then attempt gizmo drag
                if (_editorUI.SelectedObject == before)
                {
                    _gizmo.BeginDrag(mouseRay);
                }
            }
        }

        private void TrySelectObject(Ray mouseRay)
        {
            Primitive? closest = null;
            float closestDist = float.MaxValue;
            
            foreach (var obj in _sceneObjects)
            {
                // Ray-AABB intersection in world space (axis-aligned bounds around the object)
                float extent = MathF.Max(obj.Scale.X, MathF.Max(obj.Scale.Y, obj.Scale.Z)) * 0.5f;
                // Ensure a minimum clickable size
                extent = MathF.Max(extent, 0.6f);

                Vector3 bmin = obj.Position - new Vector3(extent);
                Vector3 bmax = obj.Position + new Vector3(extent);

                if (RayIntersectsAabb(mouseRay, bmin, bmax, out float t) && t < closestDist)
                {
                    closestDist = t;
                    closest = obj;
                }
            }
            
            if (closest != null)
            {
                _editorUI!.SelectedObject = closest;
            }
        }

        private static bool RayIntersectsAabb(Ray ray, Vector3 bmin, Vector3 bmax, out float t)
        {
            t = 0f;
            float tmin = 0f;
            float tmax = float.MaxValue;

            if (!Slab(ray.Origin.X, ray.Direction.X, bmin.X, bmax.X, ref tmin, ref tmax)) return false;
            if (!Slab(ray.Origin.Y, ray.Direction.Y, bmin.Y, bmax.Y, ref tmin, ref tmax)) return false;
            if (!Slab(ray.Origin.Z, ray.Direction.Z, bmin.Z, bmax.Z, ref tmin, ref tmax)) return false;

            t = tmin;
            return tmax >= tmin;
        }

        private static bool Slab(float ro, float rd, float mn, float mx, ref float tmin, ref float tmax)
        {
            const float eps = 1e-6f;
            if (MathF.Abs(rd) < eps)
            {
                return ro >= mn && ro <= mx;
            }

            float inv = 1f / rd;
            float t1 = (mn - ro) * inv;
            float t2 = (mx - ro) * inv;
            if (t1 > t2) (t1, t2) = (t2, t1);

            if (t1 > tmin) tmin = t1;
            if (t2 < tmax) tmax = t2;
            return tmax >= tmin;
        }

        private void OnMouseUp(MouseButtonEventArgs e)
        {
            if (e.Button == MouseButton.Left && _gizmo != null)
            {
                _gizmo.EndDrag();
            }
        }

        private void OnMouseMove(MouseMoveEventArgs e)
        {
            UpdateMousePositionFromState();
            
            if (_gizmo != null && _editorUI != null)
            {
                if (!IsMouseInViewport() || ImGui.IsWindowHovered(ImGuiHoveredFlags.AnyWindow))
                    return;

                var mouseRay = GetViewportMouseRay();
                
                if (_gizmo.IsDragging)
                {
                    _gizmo.UpdateDrag(mouseRay);
                }
                else
                {
                    _gizmo.CheckHover(mouseRay);
                }
            }
        }

        private bool IsMouseInViewport()
        {
            var vp = GetViewportRect();
            return _lastMousePos.X >= vp.X &&
                   _lastMousePos.X <= (vp.X + vp.Width) &&
                   _lastMousePos.Y >= vp.Y &&
                   _lastMousePos.Y <= (vp.Y + vp.Height);
        }

        private Ray GetViewportMouseRay()
        {
            var vp = GetViewportRect();
            float viewportMouseX = _lastMousePos.X - vp.X;
            float viewportMouseY = _lastMousePos.Y - vp.Y;
            return _editorUI!.Camera.GetMouseRay(viewportMouseX, viewportMouseY, vp.Width, vp.Height);
        }

        private void UpdateMousePositionFromState()
        {
            var mouse = _window.MouseState;
            _lastMousePos = new Vector2(mouse.X, mouse.Y);
        }

        private (int X, int Y, int Width, int Height) GetViewportRect()
        {
            // Use the UI-computed viewport rect (source of truth). Fallback to old math if UI isn't ready yet.
            if (_editorUI != null)
            {
                var r = _editorUI.ViewportRect;
                if (r.Width > 0 && r.Height > 0)
                    return r;
            }

            int width = _window.ClientSize.X;
            int height = _window.ClientSize.Y;
            int leftWidth = (int)MathF.Round(width * 0.20f);
            int rightWidth = (int)MathF.Round(width * 0.25f);
            int bottomHeight = (int)MathF.Round(height * 0.30f);
            int centerWidth = width - leftWidth - rightWidth;
            int centerHeight = height - bottomHeight;
            int vpX = leftWidth;
            int vpY = 100;
            int vpW = centerWidth;
            int vpH = centerHeight - 100;
            if (vpW < 1) vpW = 1;
            if (vpH < 1) vpH = 1;
            return (vpX, vpY, vpW, vpH);
        }

        public void Run()
        {
            _window.Run();
        }

        public void Dispose()
        {
            _window?.Dispose();
        }
    }
}
