using OpenTK.Graphics.OpenGL4;
using OpenTK.Mathematics;
using OpenTK.Windowing.Common;
using OpenTK.Windowing.Desktop;
using wraithspire.engine.subsystems;
using wraithspire.engine.objects.primitives;
using ImGuiNET;

namespace wraithspire.engine
{
    internal sealed class Window : IDisposable
    {
        private readonly GameWindow _window;
        private ImGuiController? _imgui;
        private objects.CheckboardTerrain? _terrain;
        private EditorUI? _editorUI;
        private List<Primitive> _sceneObjects = new List<Primitive>();
        private int _cubeCounter = 0;

        public Window(int width = 1280, int height = 720, string title = "Wraithspire Engine")
        {
            var nativeSettings = new NativeWindowSettings
            {
                ClientSize = new Vector2i(width, height),
                Title = title
            };

            var gwSettings = new GameWindowSettings
            {
                UpdateFrequency = 60
            };

            _window = new GameWindow(gwSettings, nativeSettings);
            _window.WindowState = WindowState.Maximized;

            _window.Load += OnLoad;
            _window.UpdateFrame += OnUpdateFrame;
            _window.RenderFrame += OnRenderFrame;
            _window.Resize += OnResize;
            _window.Unload += OnUnload;
        }

        private void OnLoad()
        {
            GL.ClearColor(0.1f, 0.1f, 0.1f, 1f);
            _imgui = new ImGuiController(_window);
            _editorUI = new EditorUI();
            _editorUI.SceneObjects = _sceneObjects;
            _editorUI.OnCreateCube = CreateCube;
            _terrain = new objects.CheckboardTerrain();
            _terrain.Initialize();
        }

        private void OnUpdateFrame(FrameEventArgs args)
        {
            _imgui?.Update((float)args.Time);
        }

        private void OnRenderFrame(FrameEventArgs args)
        {
            GL.Viewport(0, 0, _window.ClientSize.X, _window.ClientSize.Y);
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

            RenderScene();
            _editorUI?.Render(_window);

            _imgui?.Render();
            _window.SwapBuffers();
        }

        private void OnResize(ResizeEventArgs size)
        {
            _imgui?.WindowResized(size.Width, size.Height);
        }

        private void OnUnload()
        {
            _imgui?.Dispose();
            _terrain?.Dispose();
            foreach (var obj in _sceneObjects)
            {
                obj.Dispose();
            }
        }

        private void RenderScene()
        {
            if (_terrain == null) return;
            if (_editorUI == null) return;

            // Compute center viewport below toolbar using same layout values
            float width = _window.ClientSize.X;
            float height = _window.ClientSize.Y;
            float topMargin = 0f;
            float leftWidth = MathF.Round(width * 0.20f);
            float rightWidth = MathF.Round(width * 0.25f);
            float bottomHeight = MathF.Round(height * 0.30f);
            float centerWidth = width - leftWidth - rightWidth;
            float centerHeight = height - bottomHeight - topMargin;
            int viewportWidth = (int)centerWidth;
            int viewportHeight = (int)(centerHeight - 100f); // subtract toolbar height
            GL.Enable(EnableCap.DepthTest);
            var proj = _editorUI.CameraProjection;
            var view = _editorUI.CameraView;
            _terrain.Render(proj, view);
            
            // Render all scene objects
            foreach (var obj in _sceneObjects)
            {
                obj.Render(proj, view);
            }
        }

        private void CreateCube()
        {
            string name = _cubeCounter == 0 ? "Cube" : $"Cube ({_cubeCounter})";
            _cubeCounter++;
            
            var cube = new Cube(name);
            cube.Position = GetNextSpawnPosition();
            cube.Initialize();
            _sceneObjects.Add(cube);
        }

        private void CreateSphere()
        {
            string name = _sphereCounter == 0 ? "Sphere" : $"Sphere ({_sphereCounter})";
            _sphereCounter++;

            var sphere = new Sphere(name);
            sphere.Position = GetNextSpawnPosition();
            sphere.Initialize();
            _sceneObjects.Add(sphere);
        }

        private void CreateCapsule()
        {
            string name = _capsuleCounter == 0 ? "Capsule" : $"Capsule ({_capsuleCounter})";
            _capsuleCounter++;

            var capsule = new Capsule(name);
            capsule.Position = GetNextSpawnPosition();
            capsule.Initialize();
            _sceneObjects.Add(capsule);
        }

        private void CreateCylinder()
        {
            string name = _cylinderCounter == 0 ? "Cylinder" : $"Cylinder ({_cylinderCounter})";
            _cylinderCounter++;

            var cylinder = new Cylinder(name);
            cylinder.Position = GetNextSpawnPosition();
            cylinder.Initialize();
            _sceneObjects.Add(cylinder);
        }

        private void CreatePlane()
        {
            string name = _planeCounter == 0 ? "Plane" : $"Plane ({_planeCounter})";
            _planeCounter++;

            var plane = new Plane(name);
            plane.Position = GetNextSpawnPosition();
            plane.Initialize();
            _sceneObjects.Add(plane);
        }

        private Vector3 GetNextSpawnPosition()
        {
            // Simple grid spawn pattern so newly created objects don't overlap.
            const float spacing = 2.0f;
            const int cols = 6;

            int i = _spawnCounter++;
            int x = i % cols;
            int z = i / cols;

            float worldX = (x - (cols - 1) * 0.5f) * spacing;
            float worldZ = z * spacing;
            float worldY = 1f; // above ground
            return new Vector3(worldX, worldY, worldZ);
        }

        public void Run()
        {
            _window.Run();
        }

        public void Dispose()
        {
            _window?.Dispose();
        }
    }
}
